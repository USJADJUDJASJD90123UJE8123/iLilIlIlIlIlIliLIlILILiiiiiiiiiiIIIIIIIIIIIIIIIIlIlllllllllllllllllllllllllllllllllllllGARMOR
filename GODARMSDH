

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game.Workspace
local VirtualUser = game:GetService("VirtualUser")
local Camera = game:GetService("Workspace").CurrentCamera
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Bubble properties
local bubbleRadius = 65.5
local bubbleTransparency = 0.8
local lastTeleportTime = 0
local teleportCooldown = 0.1
local pointedModels = {}
local bubble = Instance.new("Part")

-- Anti-Bullet functionality
local antiBulletEnabled = false -- Track if the script is enabled or disabled

-- Create a blue bubble anchored to the player
bubble.Shape = Enum.PartType.Ball
bubble.Size = Vector3.new(bubbleRadius * 2, bubbleRadius * 2, bubbleRadius * 2)
bubble.Color = Color3.fromRGB(0, 0, 255)
bubble.Transparency = bubbleTransparency
bubble.Anchored = true
bubble.CanCollide = false
bubble.CastShadow = false  -- Disable shadows
bubble.Parent = workspace

-- Update the bubble's position to follow the player
RunService.Heartbeat:Connect(function()
    if character.PrimaryPart then
        bubble.Position = character.PrimaryPart.Position
    end
end)

-- Function to check if the model is rotated towards the player
local function isModelRotatedToPlayer(model, character)
    if model:FindFirstChild("HumanoidRootPart") then
        local modelPosition = model.HumanoidRootPart.Position
        local characterPosition = character.PrimaryPart.Position
        local directionToPlayer = (characterPosition - modelPosition).Unit
        local modelLookVector = model.HumanoidRootPart.CFrame.LookVector
        local dotProduct = modelLookVector:Dot(directionToPlayer)

        return dotProduct > 0.3
    end
    return false
end

-- Function to send notifications to CoreGui
local function sendNotification(message)
    StarterGui:SetCore("SendNotification", {
        Title = "ANTI BULLET DH",
        Text = message
    })
end

-- Function to move all tools to Workspace
local function moveAllToolsToWorkspace()
    for _, tool in ipairs(player.Backpack:GetChildren()) do
        if tool:IsA("Tool") then
            tool.Parent = workspace
        end
    end
end

-- Function to move all tools to Backpack
local function moveAllToolsToBackpack()
    for _, tool in ipairs(workspace:GetChildren()) do
        if tool:IsA("Tool") then
            tool.Parent = player.Backpack
        end
    end
end

-- Teleport function to move the player a specific distance away from the model
local function teleportAwayFromModel(model, distance)
    if model and model:FindFirstChild("HumanoidRootPart") then
        local modelPosition = model.HumanoidRootPart.Position
        local direction = (character.PrimaryPart.Position - modelPosition).Unit
        local newPosition = modelPosition + direction * distance
        local zigzagnewpos = newPosition + Vector3.new(-6, 0, 0) -- 6 meters to the left

        -- Randomly select newPosition or zigzagnewpos
        local finalPosition = math.random(1, 2) == 1 and newPosition or zigzagnewpos

        -- Cast a ray to check if the teleport position is valid (no collision with walls/floors)
        local rayOrigin = finalPosition
        local rayDirection = Vector3.new(0, -50, 0)  -- Ray going downward to check for ground
        local raycastResult = Workspace:Raycast(rayOrigin, rayDirection)

        -- Check if the position is above the ground (not in the void)
        if not raycastResult then
            -- If no hit, it could be in the void, so we adjust the position to a safer height
            local safePosition = finalPosition + Vector3.new(0, 10, 0)  -- Raise 10 studs above the original position
            character:SetPrimaryPartCFrame(CFrame.new(safePosition))
        else
            -- If there's no void, we use the raycast result position to ensure it's valid
            character:SetPrimaryPartCFrame(CFrame.new(finalPosition))
        end
    end
end




-- Function to move to the item and interact (Modified to lock camera during interaction)
local hasInteracted = false -- Flag to ensure the function only runs once

local function interactWithHotDog(itemName)
    -- Save the player's original position and camera position
    local origin = player.Character.HumanoidRootPart.CFrame
    local originalCameraCFrame = Camera.CFrame -- Save the current camera position and orientation

    -- Lock the camera in place by setting its CFrame to the original
    Camera.CFrame = originalCameraCFrame
    Camera.CameraType = Enum.CameraType.Scriptable  -- Lock the camera's movement and rotation

    -- Move the player's character to the item
    local item = game:GetService("Workspace").Ignored.Shop:FindFirstChild(itemName)
    if item then
        player.Character.HumanoidRootPart.CFrame = item.Head.CFrame
        wait()
        moveAllToolsToWorkspace()
        wait(0.06)
        -- Interact with the item's ClickDetector
        local clickDetector = item:FindFirstChildOfClass("ClickDetector")
        if clickDetector then
            fireclickdetector(clickDetector)
            wait()
            fireclickdetector(clickDetector)
            wait()
            fireclickdetector(clickDetector)
            wait()
            fireclickdetector(clickDetector)
            wait()
            fireclickdetector(clickDetector)
            wait()
            fireclickdetector(clickDetector)
            wait()
            fireclickdetector(clickDetector)
            wait()
            fireclickdetector(clickDetector)
        end

        -- Ensure the player returns to the original position after a short delay
        task.wait(0.1) -- Wait for a brief moment to allow the interaction to complete
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            player.Character.HumanoidRootPart.CFrame = origin
            wait(0.05)
            moveAllToolsToBackpack()
        else
            warn("Failed to return to the original position: HumanoidRootPart not found.")
        end
    else
        warn("Item not found: " .. itemName)
    end

    -- Unlock the camera by restoring its original position and orientation
    Camera.CFrame = originalCameraCFrame
    Camera.CameraType = Enum.CameraType.Custom  -- Restore normal camera behavior

    -- Reset the flag each time the function is run
    hasInteracted = true
end



local function checkArmorAndBuy()
    local saffi = Workspace.Players:FindFirstChild("SaffiTheTaffi")
    local saffilp = game.Players.LocalPlayer
    if not saffi then
        print("SaffiTheTaffi not found in Workspace.Players.")
        return false
    end

    local armor = saffi:FindFirstChild("BodyEffects") and saffi.BodyEffects:FindFirstChild("Armor")

    if not armor then
        armor = saffilp:FindFirstChild("DataFolder") and saffilp.DataFolder:FindFirstChild("Armor")
        
        -- Now check the next condition only if the first one is still nil
        if not armor then
            armor = saffilp:FindFirstChild("DataFolder") and saffilp.DataFolder.Information:FindFirstChild("Armor")
        end
    end
    
    if armor then
        if armor.Value < 90 then
            print("Armor is below 90, performing action.")
            return true
        end
    else
        print("Armor not found in BodyEffects or DataFolder.")
        return false
    end
    return false
end

-- ** NEW ** Variable to manage health drop below 55 and cooldown
local lastHealthCheckTime = 0
local healthCooldown = 2.4  -- 5 second cooldown

local function mainLoop()
    while antiBulletEnabled do
        -- Check if armor is below 90 and trigger the function once
        if checkArmorAndBuy() then
            -- Search for the hotdog item
            local hotDogItem = game:GetService("Workspace").Ignored.Shop:FindFirstChild("[Full Armor]") 
                               or game:GetService("Workspace").Ignored.Shop:FindFirstChild("[Max Armor]")
                               or game:GetService("Workspace").Ignored.Shop:FindFirstChild("[High-Medium Armor] - $2300")
                               or game:GetService("Workspace").Ignored.Shop:FindFirstChild("[High-Armor]")
                               or game:GetService("Workspace").Ignored.Shop:FindFirstChild("[Medium Armor]")
                               or game:GetService("Workspace").Ignored.Shop:FindFirstChild("[Medium-Armor]")
                               or game:GetService("Workspace").Ignored.Shop:FindFirstChild("[Full Armor] - $3639")
                               or game:GetService("Workspace").Ignored.Shop:FindFirstChild("[Medium Armor] - $1600")
                               or game:GetService("Workspace").Ignored.Shop:FindFirstChild("[Medium Armor] - $1000")
                               or game:GetService("Workspace").Ignored.Shop:FindFirstChild("Full Armor")
                               or game:GetService("Workspace").Ignored.Shop:FindFirstChild("High-Medium Armor")
                               or game:GetService("Workspace").Ignored.Shop:FindFirstChild("Medium Armor")





            -- If the hotdog item is found, interact with it
            if hotDogItem then
                interactWithHotDog(hotDogItem.Name)
                print("Teleported to buy armor: " .. hotDogItem.Name)
            else
                warn("No hotdog item found in the shop.")
            end
        end

        -- Add a short delay between each loop iteration to avoid excessive script usage
        task.wait(0.1)
    end
end

-- Toggle the Anti-Bullet functionality using the "P" key
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.KeyCode == Enum.KeyCode.P then
        antiBulletEnabled = not antiBulletEnabled
        if antiBulletEnabled then
            sendNotification("Anti Bullet Enabled")
            spawn(mainLoop)  -- Run the mainLoop when enabled
        else
            sendNotification("Anti Bullet Disabled")
        end
    end
end)

-- Main detection loop for Anti-Bullet DH
RunService.Heartbeat:Connect(function()
    if antiBulletEnabled then
        local modelsToCheck = {}

        -- Check models in Workspace
        for _, model in ipairs(Workspace:GetChildren()) do
            if model:IsA("Model") and model.Name ~= "SaffiTheTaffi" then
                table.insert(modelsToCheck, model)
            end
        end

        -- Check models in the "Players" folder if no models are found
        if #modelsToCheck == 0 then
            local playersFolder = Workspace:FindFirstChild("Players") or Workspace:FindFirstChild("players")
            if playersFolder then
                for _, model in ipairs(playersFolder:GetChildren()) do
                    if model:IsA("Model") then
                        table.insert(modelsToCheck, model)
                    end
                end
            end
        end

        -- Process each model in the list
        for _, model in ipairs(modelsToCheck) do
            local isInBubble = false

            if model:FindFirstChild("HumanoidRootPart") then
                local distance = (character.PrimaryPart.Position - model.HumanoidRootPart.Position).Magnitude
                if distance <= bubbleRadius then
                    isInBubble = true
                end
            end

            if isInBubble then
                for _, child in ipairs(model:GetChildren()) do
                    if child:IsA("Tool") then
                        if child.Name == "[Revolver]" or child.Name == "[Double-Barrel SG]" or child.Name == "rev" then
                            if isModelRotatedToPlayer(model, character) then
                                if not pointedModels[model] then
                                    local currentTime = tick()
                                    if currentTime - lastTeleportTime >= teleportCooldown then
                                        teleportAwayFromModel(model, 15)
                                        lastTeleportTime = currentTime
                                        pointedModels[model] = true
                                    end
                                end
                                break
                            end
                        end
                    end
                end
            end
        end
    end
end)
